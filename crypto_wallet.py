# -*- coding: utf-8 -*-
"""Crypto-wallet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZdFYgaR3Ng5ty33Rd_TgfBUyFWKzMQEM
"""

!pip install  gradio ecdsa requests  eth_hash[pycryptodome] eth_utils

#installing python libraries for importing different functions
# ecdsa ->SigningKey and the elliptic curve
# eth_hash and eth_utils -> keccack_256 (a hashing algorithm in ethereum for hashing public key)
#gradio->for interacting interface

from ecdsa import SigningKey,SECP256k1
from eth_hash.auto import keccak
import requests
import gradio as gr

#Generate Private and public key pair
def generate_key_pair():
  private_key = SigningKey.generate(curve = SECP256k1)   #Generating the private key with the help of elliptic curve
  public_key = private_key.get_verifying_key()    #Getting the associated public key from the private key
  return private_key,public_key,private_key.to_string().hex(),public_key.to_string().hex()   #returning the keys in human readable form

#Getting the ethereum address
def ethereum_address(public_key_hex):
  public_key_bytes = bytes.fromhex(public_key_hex)     #Coverting the public key from hex to bytes
  hashed = keccak(public_key_bytes)     #Hashing the public with the keccak algorithm of ethereum
  return '0x'+hashed[-20:].hex()   #Adding the prefix 0x to the address to make it valid


# Get balance using BlockCypher
def display_eth_balance(address):
    url = f"https://api.blockcypher.com/v1/eth/main/addrs/{address}/balance"
    response = requests.get(url)                 #getting the ethereum balance at this address
    if response.status_code == 200:              #checking if the status code is 200 then only it can move further
        data = response.json()                   #converting the json file which is received into python dictionary
        balance_wei = data.get('final_balance', 0) #balance is received in wei and if no balance then it will display 0
        balance_eth = balance_wei / 1e18          #coverting wei tno eth
        return f"{balance_eth:.6f} ETH"
    else:
        return f"Error: {response.status_code} - {response.text}"   #else display the error which is there

#Store all the entries in wallet data
wallet_data={}

# first getting the key pairs and the address
def generate_wallet():
    private_key, public_key, priv_hex, pub_hex = generate_key_pair()
    eth_addr = ethereum_address(pub_hex)
    wallet_data["private_key"] = private_key
    wallet_data["public_key"] = public_key
    return priv_hex, pub_hex, eth_addr

#Signing and Verification
def sign_and_verify(message):
   try:
        private_key = wallet_data.get("private_key")
        public_key = wallet_data.get("public_key")

        # Check if private key is valid before signing
        if private_key is None:
            return "Generate wallet first.", "", False

        # You can optionally check public key too before verifying
        if public_key is None:
            return "Generate wallet first.", "", False

        message_bytes = message.encode()
        signature = private_key.sign(message_bytes)

        verified = False
        # Verify only if public key exists
        if public_key:
            verified = public_key.verify(signature, message_bytes)

        return message, signature.hex(), verified

   except Exception as e:
        return "Error", str(e), False


#Return balance
def check_balance(addr):
    return display_eth_balance(addr)

with gr.Blocks() as demo:   #Creates Gradio Block Interface
    gr.Markdown("##Simple Ethereum Wallet")

    with gr.Tab("Generate Wallet"):
        gen_btn = gr.Button("Generate Wallet")
        private_key_out = gr.Textbox(label="Private Key")   #creating a output private key
        public_key_out = gr.Textbox(label="Public Key")
        address_out = gr.Textbox(label="Ethereum Address")

        gen_btn.click(fn=generate_wallet, outputs=[private_key_out, public_key_out, address_out])  #linking the function to the buttons

    with gr.Tab("Sign Message"):   #Tab for Signing and verification
        msg_input = gr.Textbox(label="Message to Sign")    #Message needs to be filled here as input
        msg_out = gr.Textbox(label="Original Message")
        sig_out = gr.Textbox(label="Digital Signature (hex)")
        verify_out = gr.Textbox(label="Is Signature Valid?")
        sign_btn = gr.Button("Sign & Verify")

        sign_btn.click(fn=sign_and_verify, inputs=msg_input, outputs=[msg_out, sig_out, verify_out])

    with gr.Tab("Check Balance"):  #Tab for checking the balance
        addr_input = gr.Textbox(label="Ethereum Address")   #address needs to be the input here
        balance_out = gr.Textbox(label="Balance in ETH")
        check_btn = gr.Button("Check Balance")

        check_btn.click(fn=check_balance, inputs=addr_input, outputs=balance_out)

demo.launch()

